"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Channel = void 0;
const events_1 = require("events");
class Channel extends events_1.EventEmitter {
    constructor(options) {
        super();
        this.db = options.mongoDb;
        this.options = {
            capped: true,
            size: options.size || 100000,
            max: options.max
        };
        this.closed = false;
        this.listening = null;
        this.name = options.name || 'mubsub';
        this.setMaxListeners(Infinity);
        this.listen().then(() => {
        });
    }
    close() {
        this.closed = true;
        this.tailableCursor.destroy();
        this.removeAllListeners();
        return this;
    }
    async publish(params) {
        return this.collection.insertOne(params);
    }
    subscribe({ event = 'message', callback }) {
        this.on(event, callback);
        return {
            unsubscribe: () => {
                this.removeListener(event, callback);
            }
        };
    }
    async latest(latest) {
        let doc = await this.collection
            .find(latest ? { _id: latest._id } : {})
            .sort({ $natural: -1 })
            .limit(1)
            .next();
        if (!doc) {
            doc = { type: 'init' };
            await this.collection.insertOne(doc);
        }
        return doc;
    }
    async listen(latest) {
        if (!this.collection) {
            await this.init();
        }
        latest = await this.latest(latest);
        this.tailableCursor = this.collection
            .find({ _id: { $gt: latest._id } }, {
            tailable: true,
            awaitData: true,
            sort: { $natural: 1 }
        }).stream();
        this.tailableCursor.on(`data`, (doc) => {
            const { event, message } = doc;
            if (event) {
                this.emit(event, message);
                this.emit('message', message);
            }
        });
        this.tailableCursor.on(`error`, (error) => {
            console.error(`tailableCursor.on('error')`, error);
            this.emit('cursor-error', error);
        });
        this.tailableCursor.on(`end`, () => {
            this.emit('cursor-end');
        });
        this.tailableCursor.on(`close`, () => {
            this.emit('cursor-close');
        });
        this.listening = true;
        this.emit('ready', this.listening);
    }
    async init() {
        const collections = await this.db.collections();
        let collection = collections.find((c) => c.collectionName === this.name);
        if (!collection) {
            collection = await this.db.createCollection(this.name, this.options);
        }
        else {
        }
        this.collection = collection;
        this.emit('collection', this.collection);
        return collection;
    }
    ready(callback) {
        if (this.listening) {
            callback();
        }
        else {
            this.once('ready', callback);
        }
    }
}
exports.Channel = Channel;
//# sourceMappingURL=channel.js.map